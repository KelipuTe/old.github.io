网路传递具有不确定性。

良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求。

项目要求实现简易MYSQL：
1 支持CS架构
2 支持数据存储，支持快速排序，支持查看，支持基础命令CRUD
3 支持多线程，多进程
4 支持启动方式为前台，和守护进程模式运行
5 支持事务功能
6 支持友好停止服务
7 支持主从复制

Safari 标签，TODO Reading
Bookmark，收藏
OneNote 分类存储链接

github.com/Terry-Mao/bfs 
Facebook haystack 


DDD，DTO=>DO=>PO，分别是在哪一层来处理模型转换的。 
DTO gRPC ，service -> biz
DO biz, DTO -> DO，Do business policy/rules，DO 持久化  -> repo
PO data, DO -> PO，orm /ent  



全局变量局部变量

存放变量的内存区域有大小和权限

全局变量 和 函数 在 readelf 命令的结果里面可以看得到，

readelf 命令的结果里面都是虚拟地址，要映射的

ldd 命令的结果中的 linux-vdso 是操作系统虚拟出来的 elf

局部变量一般是在栈上面的




虚拟地址 指针 虚拟地址编号 地址编号 进程虚拟地址 都是一个意思

虚拟地址有两种，编译时就确定的（符号 symbol 如 全局变量，函数等），运行时才确定的

虚拟地址的大小 和 cpu 架构有关 如果 cpu 是 64 位的 虚拟地址编号的大小就是 64 bit

注意有的命令，在打印 虚拟内存的时候会在前面补 0，显示出来的可能不够 64 bit

虚拟地址的递增方向是从低到高的




在 C 语言 下

局部变量 在函数执行后 不一定会释放 可能会真的释放 也有可能不释放

即使被释放了，说不定也能用


全局变量实际上被写到文件里去了，被写死了

局部变量可能在堆上在栈上，是可变的


gc、回收、释放空间，一般表示把内存上的数据擦除，不一定代表那个地址就不能用了


go 在编译的时候 可以确定变量应该放在 栈上还是堆上

go build -gcflags "-m -l"

小端字节序 ，想像一下 水流