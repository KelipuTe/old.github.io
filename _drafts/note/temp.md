网路传递具有不确定性。

良好的超时策略，可以尽可能让服务不堆积请求，尽快清空高延迟的请求。

项目要求实现简易MYSQL：
1 支持CS架构
2 支持数据存储，支持快速排序，支持查看，支持基础命令CRUD
3 支持多线程，多进程
4 支持启动方式为前台，和守护进程模式运行
5 支持事务功能
6 支持友好停止服务
7 支持主从复制

Safari 标签，TODO Reading
Bookmark，收藏
OneNote 分类存储链接

github.com/Terry-Mao/bfs 
Facebook haystack 


DDD，DTO=>DO=>PO，分别是在哪一层来处理模型转换的。 
DTO gRPC ，service -> biz
DO biz, DTO -> DO，Do business policy/rules，DO 持久化  -> repo
PO data, DO -> PO，orm /ent  



全局变量局部变量

存放变量的内存区域有大小和权限

全局变量 和 函数 在 readelf 命令的结果里面可以看得到，

readelf 命令的结果里面都是虚拟地址，要映射的

ldd 命令的结果中的 linux-vdso 是操作系统虚拟出来的 elf

局部变量一般是在栈上面的




虚拟地址 指针 虚拟地址编号 地址编号 进程虚拟地址 都是一个意思

虚拟地址有两种，编译时就确定的（符号 symbol 如 全局变量，函数等），运行时才确定的

虚拟地址的大小 和 cpu 架构有关 如果 cpu 是 64 位的 虚拟地址编号的大小就是 64 bit

注意有的命令，在打印 虚拟内存的时候会在前面补 0，显示出来的可能不够 64 bit

虚拟地址的递增方向是从低到高的




在 C 语言 下

局部变量 在函数执行后 不一定会释放 可能会真的释放 也有可能不释放

即使被释放了，说不定也能用


全局变量实际上被写到文件里去了，被写死了

局部变量可能在堆上在栈上，是可变的


gc、回收、释放空间，一般表示把内存上的数据擦除，不一定代表那个地址就不能用了


go 在编译的时候 可以确定变量应该放在 栈上还是堆上

go build -gcflags "-m -l"

小端字节序 ，想像一下 水流



核心本质技术知识培训机构不会告诉你的


　很多程序员放弃对于核心基础的学习，也不愿意去扩展自己的认知
甚至听从某大佬的意见去搞上层花哩胡哨的语言混饭。

从此你就失去了构建起软硬兼职的完整知识体系，失去了能够感知
计算机程序的运行机理和核心本质，高级语言是无法给予你计算机系统的
核心本质的，你也无法轻松的驾驭上层应用，你也不会更深入的用好上层高级语言
比如CPP，你只知道类成员怎么用，核心本质是什么你不懂
比如脚本语言更上层，你只知道怎么CRUD
比如你用的nginx redis mq ....你只知道会用，换了个东西你又重新去
卖命的学，核心技术你还是没有掌握，更谈不上你能更好的更深入的去理解和使用上层应用。