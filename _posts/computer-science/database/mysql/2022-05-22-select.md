---
title: "查询（select）"
date: 2022-05-27 08:00:00 +0800
tags: computer-science database mysql
comment: false
show_author_profile: true
show_subscribe: false
---

### select

MySQL 返回结果的时候不是全部处理好了再返回的，而是查询到一部分就返回一部分。比如 `select * from t limit 1000`，MySQL 可能扫描 10 条记录就返回 10 条记录，如果全部扫描完再返回，那么 MySQL 还要消耗内存存储这 1000 条记录。

### count

`count()` 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个。

性能：$count(*) = count(1) > count(主键) > count(字段)$

分析性能差别的时候，可以记住这么几个原则：

- server 层要什么就给什么
- InnoDB 只给必要的值
- 优化器只优化了 `count(*)` 的语义为 "取行数"，其他的优化并没有做

#### count(字段)

- 如果这个字段是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加
- 如果这个字段定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加

#### count(主键)

如果表里只有聚簇索引，没有二级索引。那么 InnoDB 会循环遍历聚簇索引，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

但是，如果表里有二级索引，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。因为相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 IO 成本比遍历聚簇索引的 IO 成本小。

#### count(1)

1 这个表达式它永远都不是 NULL，所以 `count(1)` 实际上就是统计表中有多少个记录。

InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 1 进去，判断是不可能为空的，按行累加。

#### count(*)

在不同的 MySQL 引擎中，`count(*)` 有不同的实现方式。

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 `count(*)` 的时候，可以直接返回。如果加了 where 条件的话，MyISAM 引擎就不能直接返回了。
- InnoDB 引擎执行 `count(*)` 的时候，由于多版本并发控制的存在，InnoDB 表执行 `count(*)` 的时候是不确定的，需要把数据一行一行地读出来，然后累积计数。

`count(*)` 并不会把全部字段取出来，而是专门做了优化，不取值。`count(*)` 肯定不是 null，直接按行累加。

`count(*)` 其实等于 count(0)，也就是说，当使用 `count(*)` 时，MySQL 会将 \* 转化为 0 来处理。所以执行过程跟 count(1) 基本一样，性能没有什么差异。

在 MySQL 5.7 的官方手册中有这么一句话：

> InnoDB handles SELECT COUNT(*) and SELECT COUNT(1) operations in the same way. There is no performance difference.

MySQL 会对 `count(*)` 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用key_len 最小的二级索引进行扫描。只有当没有二级索引的时候，才会采用聚簇索引来进行统计。

#### 不用 count

- `show table status`
  - 虽然很快，但是不准确
- 用缓存系统保存计数
  - 两个系统之间，不是原子操作，可能不准确
  - 缓存系统可能会丢失更新
- 在数据库保存计数
  - 可以用事务保证原子性，但是数值会受多版本并发控制的影响
  - 而且存表了，理论上不存在丢失的问题

### order by

#### 全字段排序

```
select a,b,c from t where a='xxx' order by b limit 100;
```

为避免全表扫描，需要在被排序的字段（a）上加上索引。

使用 explain 命令分析 SQL 语句。如果结果中的 Extra 这个字段中出现 `Using filesort` 则表示需要排序。

MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。

通常情况下，这个语句执行流程：

- 初始化 sort_buffer，确定放入 a、b、c 这三个字段
- 从二级索引 a 找到第一个满足 a='xxx' 条件的主键 id
- 到聚簇索引取出 id 对应的整行记录，取 a、b、c 三个字段，存入 sort_buffer
- 从二级索引 a 取下一个记录的主键 id
- 重复步骤 3、4 直到 a 的值不满足查询条件为止
- 对 sort_buffer 中的数据按照字段 b 做排序
- 按照排序结果取前 100 行返回给客户端

排序这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。sort_buffer_size，就是 MySQL 为排序开辟的内存（sort_buffer）的大小。

如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用硬盘临时文件辅助排序。外部排序一般使用归并排序算法。

#### rowid 排序

全字段排序只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。

如果 MySQL 认为排序的单行长度太大就会换一个算法。这个行为由 max_length_for_sort_data 控制。如果单行的长度超过这个值就会换算法。新的算法放入 sort_buffer 的字段，只有要排序的列（即 b 字段）和主键 id。

整个执行流程就变成：

- 初始化 sort_buffer，a、b、c 三个字段太大，所以只放入 b、id
- 从二级索引 a 找到第一个满足 a='xxx' 条件的主键 id
- 到聚簇索引取出 id 对应的整行记录，只取 b、id 两个字段，存入 sort_buffer
- 从二级索引 a 取下一个记录的主键 id
- 重复步骤 3、4 直到 a 的值不满足查询条件为止
- 对 sort_buffer 中的数据按照字段 b 做排序
- 遍历排序结果，取前 100 行，并回表取出 a、b、c 三个字段返回给客户端

#### 全字段排序 VS rowid 排序

如果内存够，就要多利用内存，尽量减少硬盘访问。对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。

#### 联合索引

并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，其原因是原来的数据都是无序的。如果能够保证从索引 a 上取出来的行，天然就是按照 b 递增排序的话，就可以不用再排序了。

```
alter table t add index ab(a,b);
```

添加一个联合索引 (a,b)。这样在二级索引树中，数据会先按 a 排序，再按 b 排序，最后是主键 id。这样整个查询过程的流程就变成了：

- 从联合 (a,b) 找到第一个满足 a='xxx' 条件的主键 id
- 到聚簇索引取出 id 对应的整行记录，取 a、b、c 三个字段，返回给客户端
- 从联合 (a,b) 取下一个记录的主键 id
- 重复步骤 2、3，直到查到第 100 条记录，或者是不满足 a='xxx' 条件时循环结束

### 随机查询

#### 内存临时表

```
select a from t order by rand() limit 3;
```

使用 explain 命令分析 SQL 语句。如果结果中的 Extra 这个字段中出现 `Using temporary` 则表示需要使用临时表，出现 `Using filesort` 则表示需要排序。因此这个 Extra 的意思就是，需要临时表，并且需要在临时表上排序。

对于 InnoDB 表来说，执行全字段排序会减少磁盘访问，因此会被优先选择。对于内存表，回表过程只是简单地根据数据行的位置，直接访问内存得到数据，根本不会导致多访问磁盘。所以用于排序的行越小越好了，MySQL 这时就会选择 rowid 排序。

这条语句的执行流程是这样的：

- 创建一个临时表。这个临时表使用的是 memory 引擎，表里有两个字段，第一个字段是 double 类型，为了后面描述方便，记为字段 R，第二个字段是 varchar(64) 类型，记为字段 W。并且，这个表没有建索引。
- 从 words 表中，按主键顺序取出所有的 word 值。对于每一个 word 值，调用 rand() 函数生成一个大于 0 小于 1 的随机小数，并把这个随机小数和 word 分别存入临时表的 R 和 W 字段中，到此，扫描行数是 10000。
- 现在临时表有 10000 行数据了，接下来你要在这个没有索引的内存临时表上，按照字段 R 排序。
- 初始化 sort_buffer。sort_buffer 中有两个字段，一个是 double 类型，另一个是整型。
- 从内存临时表中一行一行地取出 R 值和位置信息（我后面会和你解释这里为什么是“位置信息”），分别存入 sort_buffer 中的两个字段里。这个过程要对内存临时表做全表扫描，此时扫描行数增加 10000，变成了 20000。
- 在 sort_buffer 中根据 R 的值进行排序。注意，这个过程没有涉及到表操作，所以不会增加扫描行数。
- 排序完成后，取出前三个结果的位置信息，依次到内存临时表中取出 word 值，返回给客户端。这个过程中，访问了表的三行数据，总扫描行数变成了 20003。

#### 磁盘临时表

tmp_table_size 这个配置限制了内存临时表的大小，默认值是 16M。如果临时表大小超过了 tmp_table_size，那么内存临时表就会转成磁盘临时表。

磁盘临时表使用的引擎默认是 InnoDB，是由参数 internal_tmp_disk_storage_engine 控制的。当使用磁盘临时表的时候，对应的就是一个没有显式索引的 InnoDB 表的排序过程。

总之，不论是使用哪种类型的临时表，order by rand() 这种写法都会让计算过程非常复杂，需要大量的扫描行数，因此排序过程的资源消耗也会很大。

#### 随机排序方法

随机算法 1，取一个

取得这个表的主键 id 的最大值 M 和最小值 N;
用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;
取不小于 X 的第一个 ID 的行。

这个算法本身并不严格满足题目的随机要求，因为 ID 中间可能有空洞，因此选择不同行的概率不一样，不是真正的随机。

随机算法 2，取一个

取得整个表的行数，并记为 C。
取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。
再用 limit Y,1 取得一行。

解决了算法 1 里面明显的概率不均匀问题。

随机算法 3，取3个

取得整个表的行数，记为 C；
根据相同的随机方法得到 Y1、Y2、Y3；
再执行三个 limit Y, 1 语句得到三行数据。

### 参考

- [极客时间](https://time.geekbang.org/)
  - [MySQL 实战 45 讲](https://time.geekbang.org/column/intro/100020801?tab=catalog)
    - 14 | count(*)这么慢，我该怎么办？
    - 16 | “order by”是怎么工作的？
- [小林coding](https://xiaolincoding.com/)
  - [《图解MySQL》](https://xiaolincoding.com/mysql/)
    - 索引篇：count(*) 和 count(1) 有什么区别？哪个性能最好？

