---
title: "锁（Lock）"
create_date: 2022-05-25 08:00:00 +0800
date: 2022-05-25 08:00:00 +0800
tags: computer-science database mysql
comment: false
show_author_profile: true
show_subscribe: false
---

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。

### 全局锁

全局锁就是对整个数据库实例加锁。

MySQL 提供了一个加全局读锁的方法，命令是：`Flush tables with read lock`（FTWRL）。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。

全局锁的典型使用场景是，做全库逻辑备份。但是让整库都只读，听上去就很危险。在可重复读隔离级别下开启一个事务，也可以解决全库逻辑备份的场景。

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数 `–single-transaction` 的时候，备份数据之前就会启动一个事务，来确保拿到一致性视图。由于 MVCC 的支持，这个过程中其他事务是可以正常更新数据的。

### 表级锁

MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（MDL、meta data lock）。

表锁的语法是 `lock tables … read/write`。可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，表锁的语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。如果自己加了 a 表写锁，那么别的线程和自己，都不能写 a 表了。

元数据锁不需要显式使用，在访问一个表的时候会被自动加上，保证读写的正确性。当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。

读锁之间不互斥，读写锁之间、写锁之间是互斥的。

#### 给小表加字段

异常的场景：

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/database/mysql/lock_mdl_demo02.drawio.png">
</div>

- 事务 A 先启动，这时候会对表 t 加一个 MDL 读锁。
- 事务 B 需要的也是 MDL 读锁，因此可以正常执行。
- 事务 C 会被阻塞，因为事务 C 需要 MDL 写锁，被事务 A 的 MDL 读锁阻塞
- 事务 D 会被阻塞，因为增删改查操作需要先申请 MDL 读锁，被事务 C 的 MDL 写锁阻塞。

事务 C 之后所有要在表 t 上新申请 MDL 读锁的请求都也会被事务 C 阻塞。相当于这个表现在完全不可读写了。

解决方案：

- 先解决长事务，事务不提交，就会一直占着 MDL 锁。
- 如果更新的是一个热表，比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。

### 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。

#### 两阶段锁协议

在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。所以如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

#### 死锁和死锁检测

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。

当出现死锁以后，有两种策略：

- 一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。
- 另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。

每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 `O(n)` 的操作。

所以热点行更新导致性能问题的根源在于，死锁检测要耗费大量的 CPU 资源。

解决方案：

- 头痛医头的方法，如果能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。
- 另一个思路是在服务端控制并发度，客户端显然是控制不了的。
- 还可以考虑通过将一行改成逻辑上的多行来减少锁冲突。就是将原来一行 100 的记录拆成逻辑上的 5 行 20 的记录。

