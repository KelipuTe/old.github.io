---
title: "索引（Index）"
create_date: 2022-05-23 08:00:00 +0800
date: 2022-05-23 08:00:00 +0800
tags: computer-science database mysql
comment: false
show_author_profile: true
show_subscribe: false
---

索引（Index）就像书的目录一样，可以提高查询的效率。

### 索引模型

可以用于提高读写效率的数据结构有很多。

- 等值查询：哈希表、有序数组、跳表、搜索树（平衡二叉树、红黑树、B 树、B+ 树）等。
- 范围查询：有序数组、有序双向链表、双向跳表、搜索树（B 树、B+ 树）等。

但是数据库的场景要求等值查询和范围查询都要有。

- 哈希表适用于只有等值查询的场景，没有范围查询的能力
- 有序数组适用于只有静态存储的场景，插入和删除代价太大

两个要求同时符合的有：双向跳表、搜索树（B 树、B+ 树）等。

B+ 树相比 B 树的优势：

- 插入和删除的时候，B 树可能需要移动结点（因为 B 数的结构，如果是上层结点被删了，一定要调整结点的），B+ 树可以不移动（只删除叶子结点，上层结点只是索引用的可以不删除）。
- 在范围查询的时候，B 树使用中序遍历访问的的结点数量，比 B+ 树使用叶子结点的双向链表结构访问的结点数量多。这意味着B 树可能需要更多的硬盘 IO。

### InnoDB

InnoDB 使用的索引模型是 B+ 树。在 InnoDB 中，每一个索引都对应一棵 B+ 树，

索引是存放在数据页（文件）里的，它要占据物理空间。B+ 树为了维护索引有序性，在插入新值的时候会做必要的维护。如果页已经满了，这时候需要申请一个新的页，然后挪动部分数据过去，这个过程称为页分裂。当相邻的两个页由于删除了数据，利用率很低之后，又会将两个页做合并。

索引分为聚簇索引（主键索引）和非聚簇索引（二级索引）。

- 对主键字段建立的索引是聚簇索引，主键索引只有一个
- 聚簇索引的叶子结点存放的是实际数据，也就是用户记录
- 对普通字段建立的索引是二级索引，二级索引可以创建多个
- 二级索引的叶子结点存放的不是实际数据，而是主键值

对于主键索引，一般建议使用自增主键。因为自增主键长度小，而二级索引的叶子结点存放的是主键值，这样二级索引占的空间就小。

由于数据页的大小是固定的，索引字段长度越小，一个页内就可以放的越多，这样整体涉及的页就越少。涉及的页越少意味着硬盘 IO 越少。

对于二级索引，一般建议使用长度小、重合度小的字段，重合度越小的字段查询起来效率越高。

### 回表

如果某个查询语句使用了二级索引，但是查询的数据是整行记录。这时在二级索引找到主键后，需要回到聚簇索引中获得整个用户记录。

这个过程叫作回表，整个查询过程需要查两棵索引树。如果条件允许，尽量使用主键查询，这样就没有回表的步骤了。

### 索引覆盖

如果某个查询语句使用了二级索引，而且查询的数据就是主键或者索引字段。这时在二级索引找到主键后，不需要回到聚簇索引中获得用户记录了，因为二级索引中已经存储了主键的值和索引字段的值。这个过程叫索引覆盖，整个查询过程只查了一棵索引树，它可以显著提升查询性能。

### 索引类型

- 主键索引：数据列不允许重复，不允许为 NULL，一个表只能有一个主键。
- 唯一索引：数据列不允许重复，允许为 NULL 值，一个表允许多个列创建唯一索引。
- 普通索引：数据列允许重复，允许为 NULL 值，一个表允许多个列创建普通索引。
- 联合索引（组合索引）：多个数据列组合在一起创建的索引（唯一索引、普通索引）。

创建普通索引的时候，因为二级索引里同时有索引字段和主键字段，相当于创建了一个`普通字段+主键字段`的联合索引。

创建联合索引的时候会创建多个索引，如创建联合索引 (a,b,c) 的时候会创建 (a)、(a,b)、(a,b,c) 三个索引。使用联合索引需要遵循最左匹配原则。

### 索引下推

对于联合索引 (a,b,c)，SQL 语句 `where a=1 and c=3` 是能用到索引的，不过只能用到 a 的索引。这种属于索引截断。

MySQL 5.6 引入索引下推（index condition pushdown）优化，可以在索引遍历过程中，对索引（这里是 联合索引 (a,b,c)）中包含的字段（这里是 c）先做判断，直接过滤掉不满足条件的记录，减少回表次数。

如果用到了索引下推，那么 explain 的结果里的 extra 字段会显示 `Extra=Using index condition`。

### 索引失效（Index Invalid）

#### like

使用 `like '%xxx'` 或者 `like '%xxx%'` 的时候索引会失效。因为索引树是按照索引值有序排列的，只能进行前缀比较。

但是有个特殊的情况，如果查询的字段全部在索引树中，这个时候虽然索引失效了，但是依然会用到索引树，通过直接扫描整个索引树拿到需要的数据。因为聚簇索引树保存了全部的数据，它一定比二级索引树大，所以扫描二级索引树会快一点。

#### 联合索引非最左匹配

如果创建了一个联合索引 (a,b,c)。那么：

- `where a=1`、`where a=1 and b=2`、`where a=1 and b=2 and c=3` 都能用到索引。
- `where b=2`、`where c=3`、`where b=2 and c=3` 都用不到索引。
- 特别的 `where a=1 and c=3` 是索引截断，MySQL 5.6 及以后的版本会用到索引下推。

#### or

如果在 or 前的条件列是索引列，而在 or 后的条件列不是索引列，那么索引会失效。因为 or 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。

#### 对索引进行表达式计算

如果 id 字段有索引，那么 `where id + 1 = 10` 语句就用不到索引，因为索引保存的是索引字段的原始值，对索引进行表达式计算后的值不一定在索引里，只能全表扫描。但是 `where id = 10 - 1` 语句就可以用到索引。

#### 索引隐式类型转换

MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。`select '10' > 9; // 结果是 1` 通过这个例子就可以测试转换规则。

当索引字段是字符串的时候，如果 sql 语句是 `where 索引字段 = 123`，这时就会把索引字段转换成数字，也就不走索引了。

当索引字段是数字的时候，如果 sql 语句是 `where 索引字段 = '123'`，这时就会把 `'123'` 转换成数字，这个时候就走索引。
