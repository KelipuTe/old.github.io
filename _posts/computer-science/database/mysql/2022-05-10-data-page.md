---
title: "数据页（Data Page）"
date: 2022-05-26 08:00:00 +0800
tags: computer-science database mysql
comment: false
show_author_profile: true
show_subscribe: false
---

### InnoDB

MySQL 数据表中的记录是按照行存储的，这些记录最终是要存储到硬盘中去的。硬盘的运行速度和内存的运行速度有巨大的差距。如果每次进行硬盘 IO 的时候只处理一行的记录，这样的效率是很低的。因此 MySQL 进行硬盘 IO 的时候不以行为单位。

MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式不同。其中 InnoDB 存储引擎进行硬盘 IO 的时候就是以数据页（Data Page）为单位而不是以行为单位。InnoDB 的数据页的默认大小是 16KB，也就是每次读写硬盘的时候一次都是处理 16KB 的数据。

### 数据页

数据页包含七个部分：

| 名称 | 大小（byte） | 用途 |
| --- | --- | --- |
| 文件头（File Header） | 38 | 页的信息 |
| 页头（Page Header） | 56 | 页的状态信息 |
| 最小记录和最大记录（Infimun Supremum） | 26 | 页中的最小记录和最大记录 |
| 用户记录（User Records） | ? | 数据表的行记录 |
| 空闲空间（Free Space） | ? | 页中还没被使用的空间 |
| 页目录（Page Directory） | ? | 存储用户记录的相对位置 |
| 文件尾（File Trailer） | 8 | 校验页是否完整 |

- 文件头里有两个指针，分别指向上一个数据页和下一个数据页，数据页之间构成一个双向链表。
- 数据表中的记录，按照主键，顺序组成单链表，存储在用户记录里。
- 页目录起索引的作用，查找某条记录时不用整个遍历用户记录里的单链表。

### 页目录的创建过程

- 1、将所有的记录（不包括"已删除"）划分成几个记录组
- 2、每个记录组的最后一条记录的头信息中会存储该组一共有多少条记录。
- 3、页目录按照先后顺序存储每个记录组的最后一条记录的地址偏移量。地址偏移量也称为 slot（槽），槽相当每个记录组的索引。

因为用户记录中的行记录是按照主键从小到大排序的，所以页目录中的槽也是有序的。查找某条记录时，可以使用二分法快速定位要查询的记录在哪个槽，然后遍历槽内的所有记录，就可以找打对应的记录。

InnoDB 对每个分组中的记录条数都是有规定的：

- 第一个分组中的记录只能有 1 条记录
- 最后一个分组中的记录条数范围只能在 1~8 条之间
- 剩下的分组中记录条数范围只能在 4~8 条之间

### 查询

数据页中的页目录提高了页内记录的查询速度，但是大量的记录，一个数据页是存不下的，需要大量的数据页。因此需要通过合适的索引结构来高效确定查询的记录在哪个数据页上。

MySQL 的索引也是保存到硬盘上的，当通过索引查找某行记录时，需要先从硬盘读取索引到内存。通过索引找到记录在哪个数据页上，然后从硬盘中读取那个数据页到内存，最终从数据页中找到那条记录。查询过程中会发生多次硬盘 IO，硬盘 IO 次数越多，整体查询时间就越长。

磁盘（硬盘）的最小读写单位是扇区，扇区的大小是 512B。操作系统的最小读写单位是 Block（块），就是一次会读写多个扇区。在 Linux 中，一次磁盘 IO 操作会读写 8 个扇区，也就是块大小为 4KB。

InnoDB 采用了 B+ 树作为索引。B+ 树有利于减少硬盘 IO 的次数，而且 B+ 树适合进行关键字的范围查询。B+ 树中的每个结点都是一个数据页，非叶子结点的数据页仅用来存放数据页的索引，只有叶子结点的数据页才存放数据。所有叶子结点按照索引键排序，构成一个双向链表，便于范围查询。

查询某条记录的时候，先通过非叶子结点，定位到要找的记录在哪个叶子结点上。然后再在叶子结点的数据页中找到那条记录的详细数据。

### 空间回收

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：

- 设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起
- 设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。
- 从 MySQL 5.6.6 开始，它的默认值就是 ON。建议不论使用哪个版本，都将这个值设置为 ON。

因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。

在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，更多的删除数据的场景是删除某些行。这时就会遇到表中的数据被删除了，但是表空间却没有被回收的问题。

#### 删除数据

如果要删掉一条记录，InnoDB 引擎只会把这个记录所在的位置的空间标记为删除。如果之后要再在这个位置插入一个记录时，可能会复用这个位置。但是磁盘文件的大小并不会缩小。如果删掉了一个数据页上的所有记录，那么被复用的就是整个数据页，也是不会删除的。

但是，数据页的复用跟记录的复用是不同的。记录的复用，因为前后位置还有数据，只限于符合范围条件的数据，也就是说记录需要正好能填到那个位置。而当整个页从 B+ 树里面摘掉以后，可以复用到任何位置。

如果相邻的两个数据页利用率都很小，数据库系统就会把这两个页上的数据合到其中一个页上，另外一个数据页就被标记为可复用。

进一步地，如果用 delete 命令把整个表的数据删除，那么所有的数据页都会被标记为可复用。但是硬盘上的文件不会变小。

#### 插入数据

不止是删除数据，插入数据也会产生大量未被使用的空间。

如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。

#### 重建表

经过大量增删改的表，都是可能是存在空洞的。所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。而重建表，就可以达到这样的目的。可以使用 `alter table A engine=InnoDB` 命令来重建表。

#### Online DDL

重建表花时间最多的步骤是往临时表插入数据的过程，如果在这个过程中，有新的数据要写入到表 A 的话，就会造成数据丢失。因此，在整个 DDL 过程中，表 A 中不能有更新。也就是说，这个 DDL 不是 Online 的。

而在 MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。增加了日志文件记录和重放操作。新的方案在重建表的过程中，允许对表 A 做增删改操作。这也就是 Online DDL 名字的来源。

另外，DDL 之前是要拿 MDL 写锁的。新的方案的 alter 语句在启动的时候需要获取 MDL 写锁，但是这个写锁在真正拷贝数据之前就退化成读锁了。MDL 读锁不会阻塞增删改操作，但是可以禁止其他线程对这个表同时做 DDL。

### 参考

- [小林coding](https://xiaolincoding.com/)
  - [《图解MySQL》](https://xiaolincoding.com/mysql/)
    - 索引篇：从数据页的角度看 B+ 树