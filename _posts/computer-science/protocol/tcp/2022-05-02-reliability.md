---
title: "TCP 可靠性"
create_date: 2022-05-02 12:00:00 +0800
date: 2022-05-02 12:00:00 +0800
tags: computer-science protocol tcp
comment: false
show_author_profile: true
show_subscribe: false
---

### 重传机制

#### 超时重传

在发送报⽂时，设置⼀个定时器。当超过指定的时间后，没有收到对方的应答报⽂，就会重发该报文。

超时重传时间以 RTO（Retransmission Timeout、超时重传时间）表示。RTO 应该设置为略大于 RTT。

RTT（Round-Trip Time、往返时延）表示发送端发送报文最后一个字节到接收到应答报文第一个字节的时间。

- RTO 过大会导致真的丢包时，重传慢，效率差。
- RTO 过小会导致没有丢的包的被重发，而且重发操作会占用资源。情况严重时会挤占资源，导致更多的包重发，恶性循环。

超时重传有两种情况：

- 1、己端发送的报文丢失。
- 2、对端的应答报文丢失。

网络环境变化导致 RTT 是动态变化的，所以 RTO 的数值也是动态变化的。TCP 会采样 RTT 的时间然后加权平均，算出一个平滑的 RTT 值。除了采样 RTT，还需要采样 RTT 的波动范围，防止意外情况。

当超时重发再次超时时，RTO 加倍。如果两次超时重传都超时，就说明网络环境很差。

#### Fast Retransmit（快速重传）

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/protocol/tcp/fast_retransmit.drawio.png">
</div>

如果发送端 3 次接到一样的确认应答号，那说明前面有报文没传到接收端。根据不同的 TCP 实现，快速重传有可能只重传 seq2，也可能 seq2、seq3、seq4、seq5 全部重传。

#### SACK（Selective Acknowledgment、选择性确认）

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/protocol/tcp/sack.drawio.png">
</div>

在 TCP 头部的"选项"字段里增加 SACK 结构，SACK 会缓存哪些报文已经被接收方接收了。这样发送方就可以知道，哪些报文丢包了。这样就可以只重传丢包的数据包。

SACK 可以和快速重传结合使用。在触发快速重传时，通过 SACK 判断是哪个包丢了。

SACK 需要两端都支持才可以使用。在 Linux 中，通过 net.ipv4.tcp_sack 参数打开（Linux 2.4 后默认打开）。

#### D-SACK（Duplicate SACK）

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/protocol/tcp/d_sack_2.drawio.png">
</div>

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/protocol/tcp/d_sack_4.drawio.png">
</div>

使用 SACK 告诉发送方哪些数据被重复接收了。这样发送方就可以知道，是网络延迟，还是应答报文丢包。

#### net.ipv4.tcp_retries1 和 net.ipv4.tcp_retries2

net.ipv4.tcp_retries1 和 net.ipv4.tcp_retries2 这两个参数是 TCP 三次握手之后使用的。

当重传次数超过 tcp_retries1 时，就会指示 IP 层进行 MTU 探测、刷新路由等过程，并不会断开TCP连接。当重传次数超过 tcp_retries2 时，才会断开 TCP 连接。

同时 tcp_retries1 和 tcp_retries2 两个重传次数都受 timeout 值限制。timeout 的值是根据 tcp_retries1 和 tcp_retries2 的值计算出来的的。当重传时间超过 timeout，就不会继续重传了，即使次数还没到达。

### 滑动窗口

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/protocol/tcp/sliding_window.drawio.png">
</div>

发送端和接收端一问一答的通信模式，数据包往返的时间越长，通信的效率越低。

窗口就是无需等待确认应答，就可以继续发送数据包的最大值。窗口为 6，就表示一次可以连续发送 6 个 TCP 包。

如果中间有应答报文缺失，可以通过下一个应答报文进行确认。

发送端和接收端都有自己的发送窗口和接收窗口，己方发送窗口的大小约等于对方接收窗口的大小。

窗口大小是动态变化的。通过 TCP 报文中的 Windows 字段告诉对方自己的窗口大小。

发送窗口同时受到自己的拥塞窗口的限制，所以 $发送窗口 = min(对方的接收窗口,自己的拥塞窗口)$

#### 窗口在程序中使用指针实现

发送窗口：

- SND.WND：发送窗口大小 。
- SND.UNA：指针，指向第一个已发送但未收到应答的字节的序列号。
- SND.NXT：指针，指向第一个未发送但是可以发送的字节的序列号。
- $可用窗口大小 = SND.WND - (SND.NXT - SND.UNA)$

接收窗口：

- RCV.WND：接收窗口大小，会发给发送端。
- RCV.NXT：指针，指向期望发送方发送来的下一个字节的序列号。 

### 流量控制

发送端要考虑接收端的处理能力。如果接收端处理不过来，那么就会触发发送端的重发机制。重发机制不仅浪费网络流量，严重时还会导致网络拥堵。流量控制的目的就在于，避免接收端被单一发送端的数据填满。

TCP 报文格式中窗口占 2 个字段，也就是说，窗口最大只能是 65535 个字节。后续在 TCP 选项字段中定义了窗口扩大因子，用于扩大 TCP 窗口，其长度为 14 bit。这样两个字段加起来，一共是 30 bit 可以表示 1GB 左右的窗口大小。

理论上只要操作系统缓冲区足够大，就可以无限放大接收窗口，但是由于网络的传输能力是有限的。当发送方依据发送窗口发送超过网络处理能力的报文时，路由器会直接丢弃这些报文。

#### 最大传输速度

网络是有带宽限制的，带宽描述了网络传输能力，带宽表达的是单位时间内的流量。

$BDP（Bandwidth Delay Product、带宽时延积）= RTT * 带宽$，它描述网络中正在传输的报文的总大小。比如 100 MB/s 的带宽，10 ms 的 RTT，假设网络中塞满数据，$总数据量 = 100 MB/s * 10 ms = 1MB$。

当数据量超过带宽时延积时，就意味着网络处于过载状态，整条网络没有地方再放新的数据了。

由于发送缓冲区决定发送窗口的上限。发送窗口决定已发送未确认的网络中正在传输的报文上限。因此发送缓冲区不能超过带宽时延积。如果超过，网络会过载，容易丢包。如果很小，又不能完全发挥网络的全部带宽。

#### 操作系统缓冲区

操作系统缓冲区会影响窗口：

- 1、如果接收端来不及从缓冲区中读取数据，接收窗口可能收缩到 0。接收窗口大小为 0，就表示窗口关闭。窗口关闭时，就会阻止发送端给接收端发送数据。直到窗口非 0 时，才会继续发送数据。
- 2、如果系统资源紧张，操作系统可能会减少缓冲区的大小，这时接收窗口可能会变小，如果来不及读取数据，就会造成数据丢失。

在 Linux 中，发送缓冲区的大小是动态调节的。可以通过 `/proc/sys/net/ipv4/tcp_wmem` 配置变化范围。该配置可以控制，动态最小值，初始默认值，动态最大值三个参数。

当发送方的数据被确认后，有没有新的数据要发送时，系统会自动释放发送缓冲区多余的内存。

发送缓冲区动态调节是自动打开的，接收缓冲区动态调节需要将 `/proc/sys/net/ipv4/tcp_moderate_rcvbuf` 设为 1 来打开。

接收缓冲区的大小也是动态调节的，可以通过 `/proc/sys/net/ipv4/tcp_rmem` 配置变化范围。该配置可以控制，动态最小值（即使内存有压力也不会低于该值），初始默认值，动态最大值三个参数。

接收缓冲区可以根据操作系统空闲内存的大小来调节接收窗口。

操作系统内存是不是空闲，通过 `/proc/sys/net/ipv4/tcp_mem` 配置的参数来判断。该配置中的三个参数，是操作系统启动时，根据系统内存数量计算得到的。单位不是字节，而是内存页面数量。

- 当 TCP 内存小于第一个值，不需要释放内存；
- 当 TCP 内存大于第二个值，Linux 内核开始释放 TCP 内存，直到 TCP 内存小于第一个值。；
- 当 TCP 内存大于第三个值，Linux 内核不会再分配新的内存给 TCP。

#### Window Probe（窗口探测）

窗口关闭后，如果接收端发来的窗口非 0 报文丢包，就会陷入死锁。

为了防止这种情况，当 TCP 连接的一方收到窗口关闭报文时，就会启动一个持续计时器。当计时器超时时，就会发送一个窗口探测报文，对端确认探测报文后，返回自己现在的接收窗口大小。

如果连续 3 次窗口探测都为 0，就发送 RST 报文中断连接。

#### 糊涂窗口综合征

如果接收端来不及取走接收窗口里的数据，就会导致窗口越来越小。最后，接收端只有几个字节的窗口大小，但是发送方依然会发送这几个字节。

这时发送出去的有效数据长度（几个字节），小于 TCP + IP 头部的长度（40 个字节），过于浪费。

#### 糊涂窗口综合征的解决方案

接收端的方案：不通知小窗口。接收端窗口小于 min(MSS,缓存空间/2) 时，直接返回窗口为 0。

发送端的方案：使用 Nagle 算法。

- 1、在没有已发送未确认的报文时，立即发送。（最开始的时候一定会有一个小报文）
- 2、存在未确认报文时，直到没有已发送未确认报文或者数据长度达到 MSS 时，再发送数据。
只要没满足任何一个条件，发送端就会一直囤积数据。

Nagle 算法默认是打开的，但是类似 telnet 或 ssh 这样的数据包较小同时交互性较强的程序，则需要关闭 Nagle 算法。

Nagle 没有全局参数，应用需要根据自己的情况，通过设置 socket 选项为 TCP_NODELAY 来关闭 Nagle 算法。

当发送端的 Nagle 算法和接收端的 TCP 延迟确认一起使用时。由于两边都有延迟的步骤，时就会造成额外的时延。要解决这个网络看上去很慢的问题，就需要关闭其中一个。

#### TCP 延迟确认

没有数据的 ACK 包，它本身的网络效率是很低的。为了解决 ACK 传输效率的问题，衍生出了 TCP 延迟确认。

- 1、有响应数据要发送时，ACK 会随着数据一起立刻发送。
- 2、没有响应数据要发送时，ACK 会延迟一段时间，等待是否有响应数据可以一起发送。
- 3、如果在等待期间，对方的第二个数据报文到了，就会立刻发送 ACK。

Linux 内核中，延迟等待的时间定义如下，关键在于 HZ 参数的数值具体是多少。

- `#define TCP_DELACK_MAX ((unsigner)(HZ/5))`，最大延迟确认时间。
- `#define TCP_DELACK_MIN ((unsigner)(HZ/25))`，最小延迟确认时间。

通过设置 socket 选项为 TCP_QUICKACK 选项来关闭 TCP 延迟确认。

### 拥塞控制

当网络出现拥堵时，如果继续发送报文，可能会导致报文延迟或者丢失。这时，就会触发 TCP 重传机制。但是，重传机制会进一步加重网络的负担。这种情况会恶性循环，最终占满发送端的系统资源。拥塞控制的目的在于，避免发送端的数据填满整个网络。

#### CWnd（congestion window、拥塞窗口）

- 1、如果网络中没有出现拥塞，窗口就增大。如果网络中出现了拥塞，窗口就减小。
- 2、只要发生了超时重传，就认为网络出现了拥塞。

#### 拥塞控制算法

拥塞控制算法有 4 种：慢启动、拥塞避免、拥塞发生、快速恢复。

#### 慢启动

当发送端每收到一个应答报文时，cwnd 就 +1。初始是 1，第二次窗口 1+1=2，第三次窗口 2+2=4，是指数增加的。

当窗口增加到 ssthresh（slow start threshold、慢启动门限）时就会停止使用慢启动算法，启用拥塞避免算法。

#### 拥塞避免

当发送端每收到一个应答报文时，cwnd 就 +(1/cwnd)。拥塞避免是线性增加的。假设 ssthresh = 8，进入拥塞避免算法时，收到 8 次应答报文，cwnd 才会 +1

#### 拥塞发生

拥塞发生有两种情况：超时重传和快速重传。

- 发生超时重传时，ssthresh 重新设置为 cwnd/2。cwnd 重新设置为 1。进入慢启动。
- 发生快速重传时，cwnd 重新设置为 cwnd/2。ssthresh 重新设置为现在的 cwnd。进入快速恢复。

#### 快速恢复

当拥塞发生的情况是发生快速重传时就进入快速恢复。需要注意的是，在进入快速恢复前，cwnd 和 ssthresh 的值已经被设置过了。

在快速重传拥塞发生算法的基础上 cwnd 设置为 ssthresh +3 （收到三个 ACK 一样的包）。重传丢失的数据包。如果再收到重复的 ACK 报文，cwnd +1。直到收到新的 ACK。

收到新的 ACK 报文，证明数据都已收到。将 cwnd 设置为 ssthresh，然后进入拥塞避免。