---
title: "stack and heap memory layout（栈和堆的内存布局）"
date: 2022-07-05 08:00:00 +0800
tags: computer-science operating-system linux memory
comment: false
show_author_profile: true
show_subscribe: false
---

> 操作系统架构：x86_64 AMD Ryzen <br/>
> 操作系统版本：Ubuntu 2204

> 样例代码 <br/>
> demo-c/demo-in-linux/memory-layout/stack_var.c <br/>
> demo-c/demo-in-linux/memory-layout/stack_array.c <br/>
> demo-c/demo-in-linux/memory-layout/stack_pointer.c <br/>
> demo-c/demo-in-linux/memory-layout/heap_pointer1.c <br/>
> demo-c/demo-in-linux/memory-layout/heap_pointer2.c

- statically allocated（静态分配）：data on the stack（数据在栈区）
- dynamically allocated（动态分配）：data on the heap（数据在堆区）

### 栈

#### 局部变量

```
> ./stack

&a start address=0x7fff8fedd66c
&b start address=0x7fff8fedd670
&c start address=0x7fff8fedd674

> ./stack

&a start address=0x7ffd2cb097dc
&b start address=0x7ffd2cb097e0
&c start address=0x7ffd2cb097e4

> ./stack

&a start address=0x7ffe6a11fbac
&b start address=0x7ffe6a11fbb0
&c start address=0x7ffe6a11fbb4
```

局部变量是分配在栈上的，每次执行的时候都不一样。

```
(gdb) info proc mapping
process 5177
Mapped address spaces:

          Start Addr           End Addr       Size     Offset  Perms  objfile
      0x555555554000     0x555555555000     0x1000        0x0  r--p   /mnt/hgfs/demo-c/demo-in-linux/memory-layout/stack
      0x555555555000     0x555555556000     0x1000     0x1000  r-xp   /mnt/hgfs/demo-c/demo-in-linux/memory-layout/stack
      0x555555556000     0x555555557000     0x1000     0x2000  r--p   /mnt/hgfs/demo-c/demo-in-linux/memory-layout/stack
      0x555555557000     0x555555558000     0x1000     0x2000  r--p   /mnt/hgfs/demo-c/demo-in-linux/memory-layout/stack
      0x555555558000     0x555555559000     0x1000     0x3000  rw-p   /mnt/hgfs/demo-c/demo-in-linux/memory-layout/stack
      0x555555559000     0x55555557a000    0x21000        0x0  rw-p   [heap]
      0x7ffff7d81000     0x7ffff7d84000     0x3000        0x0  rw-p
      0x7ffff7d84000     0x7ffff7dac000    0x28000        0x0  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
      0x7ffff7dac000     0x7ffff7f41000   0x195000    0x28000  r-xp   /usr/lib/x86_64-linux-gnu/libc.so.6
      0x7ffff7f41000     0x7ffff7f99000    0x58000   0x1bd000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
      0x7ffff7f99000     0x7ffff7f9d000     0x4000   0x214000  r--p   /usr/lib/x86_64-linux-gnu/libc.so.6
      0x7ffff7f9d000     0x7ffff7f9f000     0x2000   0x218000  rw-p   /usr/lib/x86_64-linux-gnu/libc.so.6
      0x7ffff7f9f000     0x7ffff7fac000     0xd000        0x0  rw-p
      0x7ffff7fbb000     0x7ffff7fbd000     0x2000        0x0  rw-p
      0x7ffff7fbd000     0x7ffff7fc1000     0x4000        0x0  r--p   [vvar]
      0x7ffff7fc1000     0x7ffff7fc3000     0x2000        0x0  r-xp   [vdso]
      0x7ffff7fc3000     0x7ffff7fc5000     0x2000        0x0  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
      0x7ffff7fc5000     0x7ffff7fef000    0x2a000     0x2000  r-xp   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
      0x7ffff7fef000     0x7ffff7ffa000     0xb000    0x2c000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
      0x7ffff7ffb000     0x7ffff7ffd000     0x2000    0x37000  r--p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
      0x7ffff7ffd000     0x7ffff7fff000     0x2000    0x39000  rw-p   /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0  --xp   [vsyscall]
```

可以和进程内存信息比对一下，局部变量的地址都在 stack 区（栈区）。

#### 数组

一维数组或者多维数组的变量都指向数组所占内存单元的起始地址。

```
> ./stack_array

&arr1 start address=0x7fffffffde30
&arr2 start address=0x7fffffffde40
```

```
(gdb) p &arr1
$2 = (int (*)[4]) 0x7fffffffde30
(gdb) p &arr2
$3 = (int (*)[2][2]) 0x7fffffffde40
```

从内存的角度上看，不管是一维数组还是多维数组，在内存中都是以线性的结构存储的。

```
(gdb) x/16xb &arr1
0x7fffffffde30:	0x10	0x00	0x00	0x00	0x00	0x01	0x00	0x00
0x7fffffffde38:	0x00	0x10	0x00	0x00	0x00	0x00	0x01	0x00
(gdb) x/16xb &arr2
0x7fffffffde40:	0x10	0x00	0x00	0x00	0x00	0x01	0x00	0x00
0x7fffffffde48:	0x00	0x10	0x00	0x00	0x00	0x00	0x01	0x00
```

#### 指针

注意：在 64 位的 cpu 架构下，不管指针指向的变量是什么类型，指针的大小始终是 8 byte。

变量 a 是一个 int 类型的变量，一级指针 p1a 指向 变量 a，二级指针 p2a 指向 一级指针 p1a。

```
> ./stack_pointer

  &a start address=0x7ffd9ae862e4
   a         value=16
&p1a start address=0x7ffd9ae862e8
 p1a         value=0x7ffd9ae862e4
&p2a start address=0x7ffd9ae862f0
 p2a         value=0x7ffd9ae862e8
```

p1a 存储的是 a 的起始地址，p2a 存储的是 p1a 的起始地址。

```
(gdb) p &a
$1 = (int *) 0x7fffffffde44
(gdb) p &p1a
$2 = (int **) 0x7fffffffde48
(gdb) p &p2a
$3 = (int ***) 0x7fffffffde50
```

- p1a 的内存单元上存储的数据是小端字节序形式的 a 的起始地址。0x 44 de ff ff ff 7f 00 00 => 0x 00 00 7f ff ff ff de 44
- p2a 的内存单元上存储的数据是小端字节序形式的 p1a 的起始地址。0x 48 de ff ff ff 7f 00 00 => 0x 00 00 7f ff ff ff de 48

```
(gdb) x/4xb &a
0x7fffffffde44:	0x10	0x00	0x00	0x00
(gdb) x/8xb &p1a
0x7fffffffde48:	0x44	0xde	0xff	0xff	0xff	0x7f	0x00	0x00
(gdb) x/8xb &p2a
0x7fffffffde50:	0x48	0xde	0xff	0xff	0xff	0x7f	0x00	0x00
```

### 堆

#### 一级指针

p1arr1 是一个指向一维数组的指针。声明 p1arr1 后，动态分配一维数组的内存空间并存入数据。

```
> ./heap_pointer1

&p1arr1   value=0x7fffffffde50
p1arr1    value=0x5555555592a0
*p1arr1   value=16
*p1arr1+1 value=256
*p1arr1+2 value=4096
```

p1arr1 是局部变量，p1arr1 的地址在栈区。p1arr1 上存储的是动态分配出来的一维数组的内存空间的地址，这块内存空间在堆区。

```
      0x555555559000     0x55555557a000    0x21000        0x0  rw-p   [heap]
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0  rw-p   [stack]
```

可以和进程内存信息比对一下。

```
0x555555559290:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x555555559298:	0x21	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592a0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592a8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592b0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592b8:	0x51	0x0d	0x02	0x00	0x00	0x00	0x00	0x00
```

这是没有赋值前，p1arr1 指向的内存空间及其前后几个内存单元上的数据。

```
(gdb) x/48xb p1arr1-4
0x555555559290:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x555555559298:	0x21	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592a0:	0x10	0x00	0x00	0x00	0x00	0x01	0x00	0x00
0x5555555592a8:	0x00	0x10	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592b0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592b8:	0x11	0x04	0x00	0x00	0x00	0x00	0x00	0x00
```

这是没有释放前，p1arr1 指向的内存空间及其前后几个内存单元上的数据。其中，从 0x5555555592a0 开始的 12 个 byte 存储了数据。

```
x/48xb p1arr1-4
0x555555559290:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x555555559298:	0x21	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592a0:	0x59	0x55	0x55	0x55	0x05	0x00	0x00	0x00
0x5555555592a8:	0xe2	0x24	0x38	0x0d	0x3c	0xe0	0xe0	0xa9
0x5555555592b0:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
0x5555555592b8:	0x11	0x04	0x00	0x00	0x00	0x00	0x00	0x00
```

这是释放之后，p1arr1 指向的内存空间及其前后几个内存单元上的数据。可以看到，从 0x5555555592a0 开始的 12 个 byte 上的数据发生了变化。

#### 多级指针

p1 是一个 int 类型的二级指针。声明 p1 后，动态分配一级指针的内存空间。然后给这个一级指针，再动态分配一个 int 类型的内存空间并存入数据。

```
(gdb) p &p1
$1 = (int ***) 0x7fffffffde40
(gdb) p &(*p1)
$2 = (int **) 0x5555555592a0
(gdb) p &(**p1)
$3 = (int *) 0x5555555596d0
```

p1 是局部变量，p1 的地址在栈区。p1 上存储的是动态分配出来的一级指针的内存空间的地址，这块内存空间在堆区。

然后又动态申请了一块 int 类型的内存空间，这块内存空间在堆区，然后 malloc 函数返回的这块内存空间的地址存储在刚才的一级指针的内存空间里。

```
(gdb) x /8xb &p1
0x7fffffffde40:	0xa0	0x92	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) x /8xb &*p1
0x5555555592a0:	0xd0	0x96	0x55	0x55	0x55	0x55	0x00	0x00
(gdb) x /4xb &**p1
0x5555555596d0:	0x10	0x00	0x00	0x00
```

| 变量 p1 的内存地址 | 数据 | 变量 \*p1 的内存地址 | 数据 | 变量 \*\*p1 的内存地址 | 数据 |
| --- | --- | --- | --- | --- | --- |
| 0x7fffffffde40 | 0xa0 | 0x5555555592a0 | 0xd0 | 0x5555555596d0 | 0x10 |
| 0x7fffffffde41 | 0x92 | 0x5555555592a1 | 0x96 | 0x5555555596d1 | 0x00 |
| 0x7fffffffde42 | 0x55 | 0x5555555592a2 | 0x55 | 0x5555555596d2 | 0x00 |
| 0x7fffffffde43 | 0x55 | 0x5555555592a3 | 0x55 | 0x5555555596d3 | 0x00 |
| 0x7fffffffde44 | 0x55 | 0x5555555592a4 | 0x55 | - | - |
| 0x7fffffffde45 | 0x55 | 0x5555555592a5 | 0x55 | - | - |
| 0x7fffffffde46 | 0x00 | 0x5555555592a6 | 0x00 | - | - |
| 0x7fffffffde47 | 0x00 | 0x5555555592a7 | 0x00 | - | - |

### reference（参考）

- 北风之神（微信：Le-studyg）
  - 高级课程
