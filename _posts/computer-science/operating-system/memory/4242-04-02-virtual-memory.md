---
title: "Virtual Memory（虚拟内存）"
date: 2022-05-11 08:00:00 +0800
tags: computer-science 计算机科学 operating-system 操作系统 memory 内存
comment: false
show_author_profile: true
show_subscribe: false
---

### readme（说明）

笔记中涉及的图片在 draw.io 文件 `git.io/drawio/computer-science/memory/virtual-memory.drawio` 中。或者看 draw.io 文件生成的 HTML 文件，[virtual-memory.html](/image/computer-science/memory/virtual-memory.drawio.html)，渲染需要等一会。

### 虚拟内存涉及的知识点（笔记里不一定有）

- virtual memory（虚拟内存）
  - memory protection（内存保护）
  - dynamic memory allocation（动态分配内存）
  - virtual memory address（虚拟内存地址）
  - physical memory address（物理内存地址）
  - memory management unit（MMU、内存管理单元）
  - segmented memory management（段式管理）
    - segment（段）
    - segment table（段表）
    - memory fragmentation（内存碎片）
  - page memory management（页式管理）
    - page（页）
    - page table（页表）
    - missing page interruption（缺页中断）
    - multi-level page table（多级页表）
    - Translation Lookaside Buffer（TLB、页表缓存）
  - segmented paged memory management（段页式管理）

### 虚拟内存

单片机的 CPU 可以直接操作物理内存地址。但是，在这种情况下是无法同时运行多个程序的。如果多个程序都操作了同一块物理内存，那么他们就可能会互相影响，最终可能导致程序崩溃。

操作系统使用虚拟内存将进程与物理内存进行隔离，为每个进程分配独立的一套虚拟内存地址，这样每个进程就可以各玩各的互不干涉。

- 虚拟内存地址（virtual memory address）：程序使用的内存地址
- 物理内存地址（physical memory address）：硬件里面的内存地址

虚拟内存地址和物理内存地址的映射由操作系统为进程提供，进程不需要管数据到底存在哪块物理内存上。进程使用的虚拟地址，会通过 CPU 芯片中的内存管理单元（Memory Management Unit、MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。

另外，虚拟内存可以使得进程的运行内存超过物理内存大小。因为程序运行符合局部性原理，不是所有的内存都是同时在使用的。

操作系统主要有两种管理内存的方式：内存分段（Segmentation）和内存分页（Paging）。

### 段式管理

程序由若干个逻辑分段组成，如：代码分段、数据分段、栈段、堆段等。

虚拟地址由段选择子和段内偏移量两部分组成。段选择子保存在段寄存器。段选择子里的段号用作段表的索引。段表保存段基地址、段界限和特权等级等。

- 图片：virtual-memory.drawio/1-1、段式管理
- 图片：virtual-memory.drawio/1-2、段表

虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。

#### 段式管理的不足

段式管理的不足主要有两点：1、内存碎片；2、内存交换的效率低。

内存碎片有两种：

- 外部碎片：多个不连续的小物理内存，导致新的程序由于内存不够无法被装载。
- 内部碎片：程序所有的数据都被装载到了物理内存，但是这个程序有部分的数据可能并不是很常使用，这会导致内存的浪费。

内存交换可以解决外部碎片的问题。可以把程序占用的内存写到硬盘上，然后再从硬盘上读回到内存。在 Linux 中，内存交换空间（Swap 空间），这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。

对于多进程的系统来说，用分段的方式，很容易产生内存碎片。内存交换又受硬盘速度限制，效率低。

### 页式管理

整个虚拟内存空间和物理内存空间都被切成一个个固定尺寸大小的内存空间（内存页）。分页可以让内存交换时，读写的数据少一点。在 Linux 中，每一页的大小为 4KB。

虚拟地址与物理地址之间通过页表来映射，页表存储在内存里。每个进程都有自己的页表。从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址，所以页表一定要覆盖全部虚拟地址空间。内存管理单元负责将虚拟内存地址转换成物理地址。

虚拟地址分为两部分：页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。

- 图片：virtual-memory.drawio/2-1、页式管理
- 图片：virtual-memory.drawio/2-2、页表

页表里的页表项中除了物理地址之外，还有一些标记属性的数据，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。

对于一个内存地址转换，分三个步骤：

- 1、把虚拟内存地址，切分成页号和偏移量。
- 2、根据页号，从页表里面，查询对应的物理页号。
- 3、拿物理页号，加上前面的偏移量，就得到了物理内存地址。

当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常。然后进入系统内核空间，分配物理内存，更新进程页表，最后再返回用户空间，恢复进程的运行。

#### 页式管理的优点

由于内存空间都是预先划分好的，所以释放的内存都是以页为单位释放的，不会产生无法给进程使用的小内存。

如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。

分页的方式使得在加载程序的时候，不需要一次性都把程序加载到物理内存中。只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。

#### 简单分页的缺陷

简单分页有空间上的缺陷。

在 32 位的环境下，虚拟地址空间共有 4GB（2^32）。假设一个页的大小是 4KB（2^12），每个页表项 4 个字节。那么 4GB 空间就需要 100 万（2^20）个页，大概 4MB 来存储页表。每个进程都有自己的虚拟地址空间（页表）。那么，100 个进程就需要 400MB 来存储页表。

多级页表（Multi-Level Page Table）可以解决简单分页的空间上的缺陷。

#### 多级页表

多级页表把 100 多万个页表项再分页，用一个一级页表 4KB 表示全部的虚拟地址空间，一级页表一共有 1024 个页表项。每个一级页表项对应一个二级页表，每个二级页表也有 1024 个页表项。

二级页表可以在需要时进行创建。每个进程都有 4GB 的虚拟地址空间，而对于大多数程序来说，其使用到的空间远未达到 4GB，所以大多数的页表项都是空的。这样就可以节省下很多的空间。

多级页表解决了空间上的问题，但是转换工序带来了时间上的开销。

- 图片：virtual-memory.drawio/2-3、多级页表

对于 64 位的系统，多级页表变成了四级目录，分别是：PGD（page global directory、全局页目录项）、PUD（page upper directory、上层页目录项）、PMD（page middle directory、中间页目录项）、PTE（page table entry、页表项）。

#### 页表缓存

根据局部性原理，程序在一段时间内的执行会集中在整个程序的其中一个部分。相应地，执行所访问的存储空间也局限于某个内存区域。

利用这一特性，可以在 CPU 里放一块缓存，用来存放最常访问的页表项。这个缓存就是页表缓存（Translation Lookaside Buffer、TLB、快表、转址旁路缓存等）

### 段页式管理

内存分段和内存分页可以组合起来在同一个系统中使用。

先将程序划分为多个逻辑段，接着再把每个段划分为多个页。地址结构由段号、段内页号、页内位移三部分组成。每个程序一张段表，每个段一张页表，段表中的地址是页表的起始地址，而页表中的地址则是物理页号。

- 图片：virtual-memory.drawio/3-1、段页式管理

段页式地址变换中要得到物理地址须经过三次内存访问：

- 访问段表，得到页表起始地址
- 访问页表，得到物理页号
- 将物理页号与页内位移组合，得到物理地址

可用软、硬件相结合的方法实现，虽然增加了硬件成本和系统开销，但提高了内存的利用率。

### reference（参考）

- Crash Course Computer Science（计算机科学速成课）
  - [bilibili](https://www.bilibili.com/video/BV1EW411u7th)
  - [CrashCourse 字幕组](https://github.com/1c7/crash-course-computer-science-chinese)
  - [Youtube 原视频](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulI)
- [小林coding](https://xiaolincoding.com/)
  - [图解系统](https://xiaolincoding.com/os/)
