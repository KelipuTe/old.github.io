---
title: "分布式事务"
date: 2022-06-03 08:00:00 +0800
tags: computer-science 计算机科学 architecture-design 架构设计 distributed-system 分布式系统 transaction 事务
comment: false
show_author_profile: true
show_subscribe: false
---

### 经典的转账问题

- 支付宝账户表：A （id, user_id, amount）
- 余额宝账户表：B （id, user_id, amount）

用户的 user_id = 1，从支付宝转帐 1 万快到余额宝分为两个步骤：

- 1、支付宝表扣除 1 万：`UPDATE A SET amount = amount - 10000WHERE user_id = 1;`
- 2、余额宝表增加 1 万：`UPDATE B SET amount = amount + 10000WHERE user_id = 1;`

如果两个表在同一个数据库中，那么使用数据库事务就可以保证数据一致性。但是如果这两个表不在同一个数据库中，数据库事务这个方案就不能使用了，这个时候就需要使用分布式事务的解决方案。

### 事务消息

类似场景：付款点餐->获取小票->叫号取餐

支付宝表扣除 1 万后（付款点餐），生成一条余额宝表增加 1 万的消息（获取小票）。只要这条消息能被可靠的保存下来并且正确的消费掉（叫号取餐），就可以实现两个表数据的最终一致性。

#### 尽力而为

事务消息一旦被可靠的持久化，整个分布式事务，就变为实现最终一致性。

尽力而为（Best Effort）：消息正确消费后业务数据才完整，所以要尽最大努力，把消息送达到下游的消费方。常用的方案就是在消息成功送达下游前，不停地重试，直到下游成功返回结果。

上游系统可以根据下游消费消息后返回的结果，决定分布式事务到底是成功（提交）还是失败（回滚）。只有消息被消费，整个分布式事务才算是完整结束。

特别需要注意的是：所有的尽力送达的模型，都必须预扣资源。因为尽力送达后返回的结果不一定是成功，如果不预扣资源，可能就无法完成回滚操作（回滚的时候资源不够扣除）。

#### 事务性发件箱

事务性发件箱（Transactional Outbox）：业务数据与消息数据保存在同一数据库实例里，数据库事务能保证只要支付宝表里被扣了钱，消息表一定会产生与之对应的消息数据。

当上述事务提交成功后，想办法将此消息通知余额宝，余额宝处理成功后发送回复成功消息，支付宝收到回复后删除该条消息数据。

#### 轮询发布器

轮询发布器（Polling publisher）：安排一个独立的服务，定时的轮训消息表，把没有被消费的消息拿出来按 id 自增主键的顺序依次消费，这样可以保证消息的消费是有序的。

轮询的方式，会对数据库造成一定的压力。但是如果轮询的频次不够，又会有一定的延迟。

#### 事务日志跟踪

事务性发件箱的方式需要额外维护消息表，而且使得业务和消息耦合在了一起，不方便扩展。

事务日志跟踪（Transaction log tailing）：通过中间件订阅数据库日志，进而分析业务数据得到消息。或者使用一些业务场景自带的消息表（比如订单详情、交易流水等）。同样可以实现事务消息模型。

### 幂等

分布式事务一定伴随着重试，所以业务系统一定要做幂等，保证每条消息只会被消费一次。

通常的做法是上下游约定全局唯一的消息 ID，这样双方进行交互时，就可以通过消息 ID 判断消息是否被消费过。

类似的处理思路还有版本号，通过给数据打上版本号，就可以判断数据是过期的数据还是新的数据。

### 两阶段提交协议

两阶段提交协议（2PC、Two Phase Commitment Protocol）涉及到两种角色。

- 一个或多个事务参与者（participants）也可以叫资源管理器（RM、Resource Manager）：本地事务执行者。
- 一个事务协调者（coordinator）也可以叫事务管理器（TM、Transaction Manager）：协调多个参与者进行事务投票、提交、回滚。

两阶段提交的步骤分为两步：

- 投票阶段（voting phase）：协调者通知事务参与者准备提交或取消事务，然后进入表决过程。参与者将告知协调者自己是同意（本地事务执行成功，但未提交）还是反对（本地事务执行失败）。
- 提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚。

### 两阶段提交 + 事务消息

<div style="text-align: center; margin: 5px auto">
<img src="/image/computer-science/architecture-design/transaction-2pc-msg.drawio.png">
</div>

- 1、上游业务系统通知消息中间件，进入准备阶段

相当于上游系统去消息中间件那里做一个登记，表示要开始一个分布式事务。

- 2、消息中间件返回准备阶段成功后，上游业务系统执行本地事务

消息中间件返回登记成功的时候，上游系统才能开始分布式事务的操作。

- 3、上游业务系统通知消息中间件本地事务执行结果

上游业务系统，如果本地事务执行成功，就通知消息中间件可以进行下一步操作；如果本地事务执行失败，就通知消息中间件进行回滚操作，通常也就是终止本次分布式事务。

如果消息中间件没有等到上游业务系统的通知，就会主动发起查询。借助第一步的登记信息，就可以询问上游业务系统本地事务执行的结果。

- 4、如果上游业务系统本地事务执行成功，消息中间件就会设法将消息发送给下游消费系统

如果上游业务系统本地事务执行成功，那么消息中间件就需要保证这条消息一定要被下游消费系统消费掉。如果下游消费系统没有响应，消息中间件就会不停地重试。

- 5、在收到消息后，下游消费系统执行本地事务
- 6、下游消费系统通知消息中间件本地事务执行结果

这个模型中，下游消费系统只会返回成功给消息中间件，这样消息中间件就可以结束本次分布式事务。如果下游消费系统本地事务执行失败了，通常会由人工介入修正数据，因为即使失败了，这个时候也是不能回滚的，回滚操作复杂度太高。

同样的，这个步骤如果消息中间件没有等到下游消费系统的通知，也会主动发起查询。

### Seata 2PC

Seata 2PC 和传统 2PC 的区别在于：

- 传统 2PC 依赖数据库提供事务，Seata 2PC 是个服务，更符合微服务的思想。
- 传统 2PC 一直要等到提交阶段结束才会释放锁，Seata 2PC 在准备阶段结束就会释放锁。

### TCC

TCC 是 try、confirm、cancel 三个词语的缩写。TCC 要求每个分支事务都要提供三个接口：预处理（try）、确认（confirm）、撤销（cancel）。try 操作做业务检查及资源预留，confirm 做业务确认操作，cancel 实现一个与 try 相反的操作即回滚操作。

TM 首先发起所有的分支事务的 try 操作，任何一个分支事务的 try 操作执行失败，TM 将会发起所有分支事务的 cancel 操作。

若 try 操作全部成功，TM 将会发起所有分支事务的 confirm 操作，其中 confirm/cancel 操作若执行失败，TM 会进行重试。因为资源预留操作，重试可以认为是一定可以成功的，所以会一直重试直到成功。

需要注意空回滚和防悬挂的问题。

- 空回滚指的是 try 操作可能没有执行，这时 cancel 操作要能正确执行。
- 防悬挂指的是由于网络原因，cancel 操作在 try 操作之前到达了，这时要能识别出这个 try 操作是无效的。

### 微服务的分布式事务模型

- 事件驱动模型（Event sourcing）：A 服务产生一个事件，B 服务订阅 A 服务的事件；然后B 服务又产生一个事件，C 服务订阅 B 服务的事件，就这样串下去。
- Saga（编排模型）：A 服务直接调用一个集中的分布式事务编排服务，由事务编排服务去调用 B 服务、C 服务。

不管是哪一种分布式事务模型，都需要考虑万一分布式事务失败了的回滚问题。

### 参考

- 极客时间：Go 进阶训练营
