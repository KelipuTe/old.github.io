---
title: "微服务概览"
create_date: 2022-05-04 08:00:00 +0800
date: 2022-05-04 08:00:00 +0800
tags: computer-science micro-service
comment: false
show_author_profile: true
show_subscribe: false
---

- 单体架构
- 微服务架构
  - 组件服务化
    - library（库）
    - 组件服务
  - 去中心化
    - 资源、数据、治理、技术
  - 基础设施自动化
    - CI/CD
    - DevOps
  - 可用性、兼容性
    - 网络间进程间通信
      - design for failure
      - grpc
        - protocol buffer
        - health check
    - 服务契约（接口）
      - 发送时保守，接收时开放
- 服务发现
  - 元数据
    - 用业务去命名服务
    - 权重、集群、租户
  - 多集群
    - 资源隔离
    - 划分子集
  - 多租户
- 微服务设计
  - 统一入口
  - 服务划分
  - SoC（separation of concerns）关注分离
- 微服务安全
 - authentication（认证）
 - authorization（授权）

### 单体架构

虽然功能可以模块化，但是整体依然复杂。

整体打包，无法扩容单个模块。

### 微服务架构

分而治之，将模块拆分为独立服务。

每个服务的代码相对更少，可维护性更高、可测试性更高、迭代更容易。

特点：

- 原子化、单一职责、独立部属、互相隔离（资源、数据等）
- 去中心化，每个实例都可以提供完整服务。
- 服务间采用轻量级通信机制。
- 每个服务都可使用适合的技术栈（编程语言、中间件、数据库等）。
- 基础设施自动化（测试、部属、监控等）

注意点：

- 单一职责。
- 通信机制，首要考虑兼容性和移植性。优先使用语言无关的通信方式。
- 尽早创建原型，服务契约（接口）优先于实现。
- 技术栈不宜过多
- 基础设施自动化

问题点：

- 分布式系统固有的复杂性。
- 分布式的存储架构和由此带来的分布式事务问题。
- 必须考虑服务间通信不稳定和服务不可用等局部失效问题。
- 服务间的依赖，导致服务迭代时可能会涉及上下游多个服务。
- 微服务架构导致测试复杂性上升。
- 自动化依赖于运维基础设置的建设。

#### 组件服务化

单体应用：组件库被打包在内，整个重新部署

微服务应用：通过服务实现组件，单个服务重新部署

一个微服务架构的基本组成部分：

- 业务代码
- kit（译：成套工具）依赖（框架、中间件等基础设施）
- 第三方依赖
- 轻量级通信机制

#### 去中心化

- 资源：部属
- 数据：数据、缓存
- 治理：服务发现，避免集中式负载均衡
- 技术

#### 基础设施自动化

微服务架构一定伴随基础设施自动化。

开发、调试、测试、部署、监控的复杂度都会增加。

CI/CD 方法：

- CI（continuous integration、持续集成），把代码仓库、构建⼯具、测试⼯具集成在⼀起，频繁的将代码合并到主⼲然后⾃动进⾏构建和测试。
- CD（continuous delivery、持续部署）CD 是在 CI 的基础上进⾏扩展。在 CI 环节完成软件构建和测试⼯作并形成新的版本的服务后，将服务交付到类⽣产环境（staging、灰度环境、预发布环境），接受部分真实流量的测试。如果没有问题的话，则通过⼿动的⽅式部署到⽣产环境（production）。

DevOps 是一组过程、方法与系统的统称，用于 Dev（软件开发人员）、Ops（IT 运维技术人员）、QA（质量保障部门）之间的沟通、协作与整合。透过自动化的流程，使得构建、测试、发布软件能够更加地快捷、频繁和可靠。

#### 可用性、兼容性

可用性：微服务架构让原本在单体架构内部的进程间通信，变成了网络间进程间通信，引入了额外的复杂度和新的问题（负载均衡、网络延迟、通信机制、容错等）。

所以必须有 design for failure 的思想，隔离、负载均衡、超时控制、过载保护、限流、降级、重试等都需要考虑到。

兼容性：服务提供者的变更可能引发服务消费者的兼容性破坏，需要注意保持服务契约（接口）的兼容性。接口升级时注意兼容老数据。

发送时保守，接收时开放：发送时只传必要的数据，接收时容忍数据冗余。

### 服务发现

去中心化意味着服务消费者（consumer）需要通过服务发现机制去找到服务提供者（provider）。

- 客户端发现：一个服务提供者启动时会到注册中心去注册，服务消费者通过和注册中心建立心跳获取服务提供者列表，然后使用负载均衡算法访问服务提供者。
- 服务端发现：服务消费者直接访问注册中心，由注册中心查询服务提供者列表，然后使用负载均衡算法进行转发。

- 客户端发现的好处是，相比服务端发现，少一次网络跳转，但是服务消费者需要内置服务发现相关的逻辑。
- 服务端发现的好处是，服务消费者无需关注服务发现的细节，相当于解耦了，但是多了一次网络跳转，而且注册中心的存在会引入中心化。

当微服务系统的服务数量过大时，服务发现组件使用 CP 策略基本就不可行了，海量的节点加上网络抖动不可能做到一致性，这时就需要使用 AP 策略，保证可用的同时最大限度保证最终一致性。

服务在去注册中心注册的时候还可以附加很多的元数据：权重、集群、租户等。这样其他服务就可以主动识别这些元数据然后进行分流操作，可用于多集群和多租户的场景。

常见的服务发现组件：web service 的注册中心、ZooKeeper 等。

#### 多集群

- 从单一大集群可用性角度考虑，可以部属冗余的节点增加集群的可用性。
- 从单一大集群故障的角度考虑，可以考虑将单一大集群拆分成多个集群。

多集群物理上被拆成了多个集群部属，但是逻辑上属于一个集群。多集群中不同的集群可以使用不同的缓存资源，这可以提供更好的性能和更高的可用性。

如果单一大集群或者多集群都部属在一个机房内，机房故障依然会导致服务不可用。这时可以使用异地多活的部署方式。

多集群在使用过程中可以通过在元数据中添加集群信息的方式，区分某个服务属于一个逻辑集群下的多集群中的哪个集群，这样就可以实现让指定的服务消费者访问多集群中的指定集群。

这是一种隔离的思路，但是这么做是有隐患的，业务的隔离会导致缓存数据分化，当某个集群出故障需要切换流量到别的集群时，容易出现缓存穿透。

一个解决方案是，在元数据中添加多集群信息，但是多集群当一个逻辑集群用。这样缓存就是均匀分布的，需要切换流量时就不会有问题。当某个集群故障时，也可以通过元数据识别并剔除。

多集群的 health check 会带来很大的开销，如果客户端选择连接全部结点，会造成资源浪费。可以使用划分子集的思路，让客户端根据自身需要从全部结点中选择一部分节点连接。划分子集的算法需要做到将结点平均分给客户端，而且需要能够处理客户端重启。

#### 多租户

多租户（multi-tenancy）：在一个微服务架构中允许多个版本的系统共存。租户可以是测试系统，灰度（金丝雀）发布，影子系统（shadow systems）等。

多租户能够保证代码的隔离性并且能够基于流量租户做路由决策。对于传输中的数据（data in flight），如外部请求、静态数据（data at rest）、缓存、持久化存储的数据，租户都能够保证隔离性和公平性。

通常来说，微服务架构有两种基本的集成测试方式：并行测试和生产环境测试。并行测试需要一个和生产环境一样的过渡（staging）环境，并且只是用来处理测试流量。这种方法可以在不影响生产环境的情况下让开发者稳定地测试服务，同时能够在发布前更容易识别和控制 bug。并行测试是一种非常有效的集成测试方法，但是在微服务换架构中，存在一些问题。

- 如果只部属一套系统，每个团队都在测试自己的服务，混用环境导致无法测试。如果部属多套系统，则会带来很高的硬件成本。
- 测试环境模拟多套系统时，难以模拟线上真实流量，做负载测试（压力测试）。

一个解决方案就是多租户。可以把待测试服务在一个隔离的沙盒环境中启动，并且让它可以访问集成测试环境（测试、生产）。集成测试环境的正常流量保持不变，确保正常流量不被测试流量影响。同时可以把测试流量从集成环境路由到沙盒环境，沙盒环境只处理测试流量。

灰度测试是有代价的，哪怕是一个节点，也承载了一部分的流量。在生产环境中的测试有两个基本要求，它们也构成了多租户体系结构的基础。

- 隔离性：能够可靠地隔离测试和生产中的资源。
- 流量路由：能够基于识别流量类型并路由到对应的服务中去。

给入站请求绑定上下文，跨服务使用元数据（metadata）传递。在整个架构中每一个基础组件都能够理解租户信息，并且能够基于租户路由隔离流量，同时平台允许控制不同的微服务模块，比如指标和日志。在微服务架构中典型的基础组件是日志、指标、存储、消息队列、缓存以及配置。基于租户信息隔离数据需要分别处理基础组件。

多租户架构本质上描述为：跨服务传递请求携带上下文（context），数据隔离的流量路由方案。利用服务发现注册租户信息，注册成特定的租户。

### 微服务设计

#### 统一入口

微服务需要统一入口对外暴露内部服务。

没有个统一入口时会产生的问题：

- 客户端直接访问内部服务，造成强耦合。
- 客户端获取复杂数据时需要请求多个服务。
- 内部服务的实现可能不一样，对外接口的协议和格式不统一。
- 内部服务需要处理不同客户端的适配和兼容工作（针对用户端和管理端的数据裁剪等）。
- 统一的逻辑（路由、鉴权、安全、限流等）分布于各个内部服务，无法收敛。

统一入口可以解决的问题：

- 隔离客户端和内部服务，这样升级内部服务就会比较容易。
- 客户端获取复杂数据时，可以由网关来进行数据的聚合工作。
- 内部服务不同的通信协议和数据格式可以在网关统一转换。
- 不同客户端的适配和兼容工作可以由网关进行，网关可以根据不同的客户端提供定制化的 API。
- 网关提供统一逻辑（路由、鉴权、安全、限流等），内部服务只能通过内网访问。

统一入口可以再拆分为 API Gateway（网关）和 BFF（backend for frontend、聚合层）。

- API Gateway 负责处理跨横切面（cross-cutting concerns）的功能（路由、鉴权、安全、限流等）。
- BFF 专注于业务逻辑。外部请求先通过负载均衡访问网关，网关进行统一的认证和拦截。通过网关后，认证信息会放在请求元数据中（HTTP 头部等），然后访问 BFF，由 BFF 扇出访问内部服务。

#### 服务划分

- 业务（Business Capability）
- DDD（Bounded Context、限界上下文）
- CQRS：命令端（写）和查询端（读）

### 微服务安全

- 认证：你是谁
- 授权：你能干什么

### 参考

- 极客时间：Go 进阶训练营
- 搜索：服务发现
- 搜索：分布式系统 CAP
  - [分布式系统的CAP定理详解](https://zhuanlan.zhihu.com/p/335617791)
- 搜索：CI/CD
  - [CI/CD 方法](https://zhuanlan.zhihu.com/p/228272483)
- 搜索：DevOps
  - [什么是DevOps？](https://www.zhihu.com/question/58702398)
