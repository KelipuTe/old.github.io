---
title: "缓存"
date: 2022-06-02 08:00:00 +0800
tags: computer-science 计算机科学 cache 缓存
comment: false
show_author_profile: true
show_subscribe: false
---

### 缓存刷新策略

- 更新数据库后删除缓存

删除缓存的问题在于，如果删除的缓存是热点缓存，那么大量的请求会透传到数据库，有一定的风险。

一个解决方案是，缓存系统把这个删掉的缓存暂存一小段时间。请求过来时，返回这个过期的数据，并标记出来是过期的数据，并且触发回填操作。前端在收到这个过期的数据后，可以自行判断要不要使用。

- 更新数据库后更新缓存

更新缓存的问题在于，如果并发的两个请求都修改了缓存的值。在数据库层面，可以通过加锁，保证顺序是正确的，但是回填缓存的时候，由于网络等原因，这个顺序就无法保证了。

### 控制并发

分布式缓存系统的其中一个节点的负载是有限的，上游服务不能不加限制的访问。

比如上游系统的一台服务器有 50 个请求同时访问缓存系统的一个 key，如果不加限制那就是 50 次请求打到缓存系统上。如果上游系统服务器有 100 台的话，总共就有 5000 次请求。如果并发量再大一点，服务器再多一点，缓存系统的节点就有可能过载了。

这时就需要使用归并回源的思路。在同一台服务器上的 50 个请求对这个 key 的访问，其实只需要其中一个请求去拿数据，拿回来和剩下的 49 个请求分享就行了。

### 缓存穿透

- 和控制并发一样，缓存穿透到数据库时，也可以使用归并回源的思路。
- 分布式锁：穿透过去的请求，先要设置一个和缓存 key 相关的分布式锁，然后尝试加锁。如果抢到锁，就可以访问数据库，回来之后更新本地 key 的数据并触发回填。如果没抢到锁，就尝试继续读缓存和加锁，要么从缓存中读到拿到锁的请求回填的数据，要么抢到锁去访问数据库。
- 队列：穿透过去的请求，使用归并回源的思路，但是不直接回填缓存，而是触发异步回填任务。这种操作可以防止服务器集群 cache miss 时多次回填，特别是这个缓存的数据还很大的时候。

解决缓存穿透的核心就是归并回源，防止穿透过去的请求让数据库过载。

### 缓存代理

在应用程序和缓存组件之间加一层代理（proxy），代理提供和缓存组件一样的接口。应用程序可以像使用缓存组件一样使用代理，不需要修改任何代码。缓存组件的扩容、缩容、负载均衡都由代理处理，应用程序不需要关心。

### 缓存技巧

- 在易读的前提下，key 尽量设置的小，key 也是占空间的。
- value 序列化存储，尽可能减少空间的使用。
- 把一个 key 拆分成多份、给 key 设置多个副本。目的是防止热点数据集中打到某个节点。
- 空缓存：对于数据库查空的数据，需要设置空缓存，防止每次请求都 miss 然后打到数据库。
- 针对特殊场景安排响应的缓存策略。比如服务降级时，如果缓存 miss 了，就不触发回填操作。
